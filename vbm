#!/usr/bin/perl
#
# script to boot and attach console
# to headless VirtualBox machine
#
use Data::Dumper;
use Getopt::Std;
use strict;
use File::Path qw(make_path);
use File::Temp qw(tempfile);
use File::Basename;
use vars qw/ %opt /;

# read in the config file
our ($vbdiskdir,$vbheadless,$vbheadlessargs,$vbmanage,$socat,$socatargs,$VMs);
my $config_file = $ENV{'HOME'}."/.vbm";
require $config_file;

my $opt_string='m:n:o:a:c:s:N:AblhpvLD';
if(! getopts( "$opt_string", \%opt )){ usage(); exit; }
if(! -d "$vbdiskdir"){ make_path("$vbdiskdir") }
# init the VMs hash
read_vms();

our $conpipe="/tmp/vb-".$opt{n}."-console";
our $titlebar=$opt{n}." console";

if($opt{h}){ usage(); exit; }
if($opt{l}){ listvms(); exit; }
if($opt{m}){ mountcd(); exit; }
if($opt{a}){ add_disks(); exit; }
if($opt{r}){ $vbheadlessargs = "--vrde on --vrdeproperty TCP/Ports=3389-3400"; }
if($opt{b}){ boot_vm(); exit; }
if($opt{p}){ poweroff_vm(); exit; }
if($opt{A}){ poweroff_acpi_vm(); exit; }
# print usage and bail if we get to here
usage(); exit;

sub poweroff_vm {
  my $cmdstring = "$vbmanage controlvm $opt{n} poweroff";
  system($cmdstring);
}

sub poweroff_acpi_vm {
  my $cmdstring = "$vbmanage controlvm $opt{n} acpipowerbutton";
  system($cmdstring);
}

sub set_title_bar {
  my($titlebar)=@_;
  print "\033]0;${titlebar}\007";
}

sub read_vms {
  $VMs={};
  my ($vm);
  open(foo, "$vbmanage list -l vms |");
  while(<foo>){ chomp;
    if(/^Name:\s+(\S+.*)$/){ $vm=$1; }
    if(/^UUID:\s+(\S+)$/){ $VMs->{$vm}->{'uuid'}=$1.")"; }
    if(/^State:\s+(\S+.*)\.\d+\)$/){ $VMs->{$vm}->{'state'}=$1.")"; }
    if(/^Config file:\s+(\S+.*)$/){ $VMs->{$vm}->{'dir'}=dirname($1); }
    if(/^(\S+)\s\((\d+)\,\s(\d+)\):\s(\S+.*)\s\(UUID\:\s(\S+)\)$/){ $VMs->{$vm}->{$1}->{$2}->{$3}->{'file'}=$4; $VMs->{$vm}->{$1}->{$2}->{$3}->{'uuid'}=$5;}
    if(/^(\S+)\s\((\d+)\,\s(\d+)\):\s(Empty)$/){ $VMs->{$vm}->{$1}->{$2}->{$3}->{'file'}=$4; $VMs->{$vm}->{$1}->{$2}->{$3}->{'uuid'}='';}
    if(/^NIC\s(\d):\s+MAC:\s(\S+)\,\sAttachment\:\s(\S+.*)\,\sCable connect/){ $VMs->{$vm}->{'nic'}->{$1}->{'mac'}=$2; $VMs->{$vm}->{'nic'}->{$1}->{'attach'}=$3; }
  }
  #print Dumper $VMs if $opt{D};
}

sub add_disks {
  if( ! $opt{N} ){ usage(1); }
  if( ! $opt{c} ){ usage(1); }
  if( ! $opt{s} ){ usage(1); }
  my @nodes=split(',', $opt{N});
  my $shared=1;
  if(scalar(@nodes) == 1 ){
    my $node=$nodes[0];
    $vbdiskdir = $VMs->{$node}->{'dir'};
    $shared=0;
  }
  # add controller if needed
  foreach my $node(@nodes){
    my $ctlr=uc($opt{c});
    my $cmd = "$vbmanage storagectl '$node' --name $ctlr --add $ctlr > /dev/null 2>&1";
    if($ctlr eq "SAS"){ $cmd = "$vbmanage storagectl '$node' --name $ctlr --add $ctlr --portcount 8 > /dev/null 2>&1"; }
    print "Running: $cmd\n" if $opt{D};
    system($cmd);
  }
  print "Using $vbdiskdir for disk creation.\n" if $opt{v};
  my $cmdstring;
  my $disks=$opt{a};
  print "Creating $disks disks.\n" if $opt{v};
  for(my $I=1; $I<=$disks; $I++){
    print "Creating $I of $disks disks.\n" if $opt{v};
    my $diskname = disk_tmpfile();
    print "creating $diskname\n" if $opt{v};
    my $size = (1024 * $opt{s});
    my $cmd;
    if($shared){ $cmd = "$vbmanage createmedium disk --size $size --variant Fixed --filename '$diskname' 2>&1\n"; }
    else{ $cmd = "$vbmanage createmedium disk --size $size --filename '$diskname' 2>&1\n"; }
    print $cmd if $opt{v};
    my $uuid='';
    open(foo, "$cmd |");
    while(<foo>){
      chomp;
      if(/UUID: (\S+)$/){ $uuid=$1 }
    }
    foreach my $node(@nodes){
      print "Attaching new disk $uuid to $node\n" if $opt{v};
      disk_attach($node,$uuid,$shared);
    }
  }
}

sub disk_attach {
  my ($node, $diskuuid, $shared) = @_;
  my $ctlr=uc($opt{c});
  my ($port, $portmax, $targetmax);
  if($ctlr eq "SCSI"){ $portmax=15; $targetmax=0; }
  elsif($ctlr eq "SATA"){ $portmax=29; $targetmax=0; }
  elsif($ctlr eq "SAS"){ $portmax=7; $targetmax=0; }
  elsif($ctlr eq "IDE"){ $portmax=1; $targetmax=1; }
  else{
    print "\nUnknown controller: $ctlr\nRemoving disk, $diskuuid\n";
    exec("$vbmanage closemedium $diskuuid --delete")||die;
    exit(1);
  }
  # find an unused port
  my $attached=0;
  for(my $i=0; $i<=$portmax; $i++){
    for(my $j=0; $j<=$targetmax; $j++){
      print "Checking port $i and device $j\n" if $opt{D};
      if(! defined $VMs->{$node}->{$ctlr}->{$i}->{$j}->{'file'}){
        my $cmd = "$vbmanage storageattach '$node' --storagectl $ctlr --type hdd --port $i --device $j --medium $diskuuid";
        if($shared){ $cmd .= " --mtype shareable"; }
        print "Running: $cmd\n" if $opt{D};
        system($cmd);
        read_vms();
        return;
      }
    }
  }
  print "Unable to attach disk, deleting.\n";
  system("$vbmanage closemedium $diskuuid --delete > /dev/null 2>&1");
}

sub disk_tmpfile {
  (undef, my $diskname) = tempfile("vmdiskXXXX", DIR=>"$vbdiskdir", OPEN=>0, SUFFIX=>"");
  return($diskname);
}

sub mountcd {
  my(%sata);
  open(foo, "$vbmanage showvminfo $opt{n} --machinereadable |") or die;
  while(<foo>){ chomp;
    if(/^\"(\S+)\-(\d+)\-\d+\"\=\S+.*\.iso\"$/){
      my $c = $1; my $p = $2;
      my $cmdstring = "$vbmanage storageattach $opt{n} --storagectl $c --port $p --device 0 --type dvddrive --medium emptydrive";
      exec($cmdstring)||die "exec failed: $cmdstring";
      sleep 3;
      my $cmdstring = "$vbmanage storageattach $opt{n} --storagectl $c --port $p --device 0 --type dvddrive --medium $opt{m}";
      exec($cmdstring)||die "exec failed: $cmdstring";
    }
    elsif(/^\"(\S+)\-(\d+)\-\d+\"\=\"emptydrive\"/){
      my $cmdstring = "$vbmanage storageattach $opt{n} --storagectl $1 --port $2 --device 0 --type dvddrive --medium $opt{m}";
      exec($cmdstring)||die "exec failed: $cmdstring";
    }
  }
}

sub listvms {
  my ($vm, $maxl, $controller);
  my @controllers=("IDE", "SATA", "SCSI", "SAS");
  foreach $vm(sort keys(%{$VMs})){ my $l=length($vm); if($l>$maxl){$maxl=$l;} }
  print "\n\n  Virtual Machines\n\n";
  foreach $vm(sort keys(%{$VMs})){
    my $n;
    while(length($n.$vm)<$maxl){ $n.=" "; }
    print "    $n$vm  ::  $VMs->{$vm}->{'state'}\n";
    if($opt{L}){
      foreach $controller(sort keys(%{$VMs->{$vm}->{'nic'}})){
        print "$n      NIC $controller :: MAC $VMs->{$vm}->{'nic'}->{$controller}->{'mac'} :: $VMs->{$vm}->{'nic'}->{$controller}->{'attach'}\n";
      }
      foreach $controller(sort(@controllers)){
        foreach my $i(sort keys(%{$VMs->{$vm}->{$controller}})){
          foreach my $j(sort keys(%{$VMs->{$vm}->{$controller}->{$i}})){
            print "$n      $controller ($i, $j) $VMs->{$vm}->{$controller}->{$i}->{$j}->{'file'}  UUID $VMs->{$vm}->{$controller}->{$i}->{$j}->{'uuid'}\n";
          }
        }
      }
    }
  }
}

sub boot_vm {
  # set the title bar
  set_title_bar($titlebar);

  # connect console if running
  if(checkrunning($opt{n})){ consoleconnect($conpipe); }

  # boot vm
  if( my @bo = split(/\,/,$opt{o}) ){
    my $cmdstring = "$vbmanage modifyvm $opt{n} --boot1 $bo[0] --boot2 $bo[1] --boot3 $bo[2] --boot4 $bo[3]";
    system($cmdstring);
  }
  bootmachine($opt{n});
  if(checkrunning($opt{n})){ consoleconnect($conpipe); }
  die "Can not boot or console to $opt{n}";
}

sub consoleconnect {
  my($pipefoo)=@_;
  if(! -e $pipefoo){ die "Console pipe does not exist: $pipefoo"; }
  system("clear");
  my $cmdstring = $socat." ".$socatargs." ".$pipefoo;
  exec($cmdstring)||die "exec failed: $cmdstring";
}

sub checkrunning {
  my($machine)=@_;
  my $running=0;
  open(foo,"$vbmanage list runningvms |")||die;
  while(<foo>){
    chomp;
    if(/^\"$machine\"\s.*/){ $running=1; }
  }
  close foo;
  return($running);
}

sub bootmachine {
  my($machine)=@_;
  my $cmdstring = "$vbmanage modifyvm $machine --uartmode1 server /tmp/vb-${machine}-console";
  system($cmdstring);
  my $cmdstring = "$vbmanage modifyvm $machine --uart1 0x3f8 4";
  system($cmdstring);
  $cmdstring = "$vbheadless $vbheadlessargs -s $machine";
  defined(my $pid = fork)||die "Can't fork: $!";
  if($pid){
    # wait a bit for the machine to start
    sleep 5;
  }else{
    # child needs to exec the vm start command
    open STDIN, '/dev/null'   or die "Can't read /dev/null: $!";
    open STDOUT, '>/dev/null' or die "Can't write to /dev/null: $!";
    open STDERR, '>/dev/null' or die "Can't write to /dev/null: $!";
    exec($cmdstring)||die;
  }
}

sub usage {
  print qq|
    usage:

    $0 -l [ -L ]
    $0 -n VM -A
    $0 -n VM -b [ -v ]
    $0 -n VM -b [ -o dev1,dev2,dev3,dev4 ]
    $0 -n VM -m /path/to/cdimage.iso
    $0 -n VM -p
    $0 -a X -c XXX -s XX -N VMx,VMy,VMz,... [ -v ]
    $0 -h

    -l : list VirtualBox machines
    -L : long listing includes networks and disks
    -n : name of the VirtualBox machine
    -A : send ACPI power off request
    -b : power on and boot machine
    -m : mount iso on node
    -o : when used with -b, specify the 4
         devices none,floppy,dvd,disk,net
    -r : enable VRDE server
    -a : add X drives to VM(s)
    -c : controller name should be SAS or SCSI
    -s : size of drive(s) in GB
    -N : comma seperated list of VMs to which the disks should be attached
    -p : power off machine
    -v : verbose output
    -h : duh!

|;
}
